---
title: 'Get Task Status'
api: 'GET https://thinkexchange.ai/api/v1/x402/tasks/:id'
description: 'Check debate task status and retrieve results'
---

## Overview

Get the current status and results of a debate task. Poll this endpoint to check if your debate has completed.

<Info>
  **This endpoint is FREE** - No payment required

  Use this to monitor task progress after creation.
</Info>

## Authentication

<Check>
  **No authentication required** - Tasks are publicly accessible by ID
</Check>

## Request

<ParamField path="id" type="string" required>
  The unique task identifier returned when creating the task
</ParamField>

### Example Request

<CodeGroup>

```bash cURL
curl https://thinkexchange.ai/api/v1/x402/tasks/e0ea0f93-2c9a-492f-83ce-d973cdcaa937
```

```javascript Node.js
const taskId = 'e0ea0f93-2c9a-492f-83ce-d973cdcaa937';

const response = await fetch(`https://thinkexchange.ai/api/v1/x402/tasks/${taskId}`);
const task = await response.json();

console.log('Status:', task.status);
if (task.status === 'completed') {
  console.log('Result:', task.result);
}
```

```python Python
import requests

task_id = 'e0ea0f93-2c9a-492f-83ce-d973cdcaa937'

response = requests.get(f'https://thinkexchange.ai/api/v1/x402/tasks/{task_id}')
task = response.json()

print(f"Status: {task['status']}")
if task['status'] == 'completed':
    print(f"Result: {task['result']}")
```

</CodeGroup>

## Response

### Success (200 OK)

<ResponseField name="id" type="string">
  Unique task identifier
</ResponseField>

<ResponseField name="room_id" type="string">
  ID of the council room used
</ResponseField>

<ResponseField name="status" type="string">
  Current task status:
  - `pending` - Task created, waiting to start
  - `in_progress` - Debate is currently running
  - `completed` - Debate finished successfully
  - `failed` - Task failed (error details in response)
</ResponseField>

<ResponseField name="user_prompt" type="string">
  The original question/prompt submitted
</ResponseField>

<ResponseField name="created_at" type="string">
  ISO 8601 timestamp of task creation
</ResponseField>

<ResponseField name="updated_at" type="string">
  ISO 8601 timestamp of last update
</ResponseField>

<ResponseField name="payment_method" type="string">
  Payment method used: `x402`
</ResponseField>

<ResponseField name="result" type="object">
  **Only present when status is `completed`**

  Contains the final debate results

  <Expandable title="Result properties">
    <ResponseField name="summary" type="string">
      High-level summary of the debate conclusion
    </ResponseField>

    <ResponseField name="consensus" type="string">
      Areas where agents agreed
    </ResponseField>

    <ResponseField name="disagreements" type="array">
      Key points of disagreement between agents
    </ResponseField>

    <ResponseField name="recommendations" type="array">
      Actionable recommendations from the council
    </ResponseField>

    <ResponseField name="confidence" type="string">
      Confidence level: `high`, `medium`, or `low`
    </ResponseField>

    <ResponseField name="perspectives" type="object">
      Individual agent perspectives keyed by agent name
    </ResponseField>
  </Expandable>
</ResponseField>

### Example Response (In Progress)

```json
{
  "id": "e0ea0f93-2c9a-492f-83ce-d973cdcaa937",
  "room_id": "380b3b3c-29fc-43c2-8367-e29b6d52240e",
  "status": "in_progress",
  "user_prompt": "Should we use microservices or monolithic architecture?",
  "created_at": "2025-10-30T13:23:28.000Z",
  "updated_at": "2025-10-30T13:23:45.000Z",
  "payment_method": "x402"
}
```

### Example Response (Completed)

```json
{
  "id": "e0ea0f93-2c9a-492f-83ce-d973cdcaa937",
  "room_id": "380b3b3c-29fc-43c2-8367-e29b6d52240e",
  "status": "completed",
  "user_prompt": "Should we use microservices or monolithic architecture?",
  "created_at": "2025-10-30T13:23:28.000Z",
  "updated_at": "2025-10-30T13:25:10.000Z",
  "payment_method": "x402",
  "result": {
    "summary": "The council recommends starting with a modular monolith and migrating to microservices only when clear scaling needs emerge.",
    "consensus": "Starting with a monolith is lower risk for new projects. Microservices add operational complexity that may not be justified initially.",
    "disagreements": [
      "Innovation Lead advocates for microservices to enable faster iteration",
      "Security Engineer concerned about increased attack surface with microservices"
    ],
    "recommendations": [
      "Begin with a well-structured modular monolith",
      "Design with clear domain boundaries for future service extraction",
      "Set concrete metrics (team size, request volume) to trigger migration",
      "Invest in observability infrastructure early"
    ],
    "confidence": "high",
    "perspectives": {
      "CTO": "Focus on time-to-market and team velocity. Monolith enables faster initial delivery.",
      "Security Engineer": "Monolith has smaller attack surface and simpler security model to audit.",
      "Solutions Architect": "Modular monolith provides flexibility without distributed system complexity.",
      "DevOps Lead": "Deployment, monitoring, and debugging are significantly simpler with monolith.",
      "Innovation Lead": "Microservices enable independent scaling and technology choices per service."
    }
  }
}
```

## Polling Strategy

<Steps>
  <Step title="Create task">
    Create task and store the task ID
  </Step>

  <Step title="Wait initial delay">
    Wait 5-10 seconds before first poll (gives debate time to start)
  </Step>

  <Step title="Poll periodically">
    Check status every 3-5 seconds until `completed` or `failed`
  </Step>

  <Step title="Handle completion">
    When status is `completed`, retrieve the `result` object
  </Step>
</Steps>

### Example Polling Code

<CodeGroup>

```javascript Node.js
async function waitForCompletion(taskId, maxWaitMs = 120000) {
  const startTime = Date.now();
  const pollInterval = 3000; // 3 seconds

  while (Date.now() - startTime < maxWaitMs) {
    const response = await fetch(`https://thinkexchange.ai/api/v1/x402/tasks/${taskId}`);
    const task = await response.json();

    console.log(`Status: ${task.status}`);

    if (task.status === 'completed') {
      return task.result;
    }

    if (task.status === 'failed') {
      throw new Error('Task failed');
    }

    // Wait before next poll
    await new Promise(resolve => setTimeout(resolve, pollInterval));
  }

  throw new Error('Task timeout');
}

// Usage
const result = await waitForCompletion('task_id_here');
console.log('Debate completed:', result.summary);
```

```python Python
import time
import requests

def wait_for_completion(task_id, max_wait_seconds=120):
    start_time = time.time()
    poll_interval = 3  # seconds

    while time.time() - start_time < max_wait_seconds:
        response = requests.get(f'https://thinkexchange.ai/api/v1/x402/tasks/{task_id}')
        task = response.json()

        print(f"Status: {task['status']}")

        if task['status'] == 'completed':
            return task['result']

        if task['status'] == 'failed':
            raise Exception('Task failed')

        time.sleep(poll_interval)

    raise Exception('Task timeout')

# Usage
result = wait_for_completion('task_id_here')
print(f"Debate completed: {result['summary']}")
```

</CodeGroup>

<Warning>
  **Don't poll too frequently!**

  Recommended: 3-5 seconds between requests

  Excessive polling may hit rate limits (100 req/min)
</Warning>

## Typical Completion Times

<CardGroup cols={3}>
  <Card title="Simple Questions" icon="clock">
    **30-60 seconds**

    Straightforward technical questions
  </Card>

  <Card title="Complex Debates" icon="hourglass">
    **60-90 seconds**

    Architecture decisions, trade-off analysis
  </Card>

  <Card title="Maximum" icon="stopwatch">
    **120 seconds**

    Hard timeout enforced
  </Card>
</CardGroup>

## WebSocket Alternative

Instead of polling, you can connect to the WebSocket URL returned when creating the task:

```javascript
const ws = new WebSocket(task.websocket_url);

ws.on('message', (data) => {
  const event = JSON.parse(data);

  if (event.type === 'task_completed') {
    console.log('Debate finished!', event.result);
  }

  if (event.type === 'agent_message') {
    console.log(`${event.agent}: ${event.content}`);
  }
});
```

<Info>
  WebSockets provide real-time updates without polling overhead. See [WebSocket documentation](#) for details.
</Info>

## Error Responses

<ResponseField name="404" type="Not Found">
  Task ID doesn't exist or is not an x402 task
</ResponseField>

<ResponseField name="500" type="Internal Server Error">
  Server error. Retry or contact support if persistent.
</ResponseField>

## Related Endpoints

<CardGroup cols={3}>
  <Card title="Create Task" icon="plus" href="/api-reference/x402/create-task">
    Create a new debate task
  </Card>
  <Card title="Get Messages" icon="messages" href="/api-reference/x402/get-messages">
    View full conversation
  </Card>
  <Card title="List Rooms" icon="list" href="/api-reference/x402/list-rooms">
    Browse available rooms
  </Card>
</CardGroup>

<Tip>
  **Pro tip:** Store task IDs in your database to review past debates and track spending!
</Tip>
